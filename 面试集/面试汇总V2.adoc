= {toc-title}
:author: JouZiton
:doctype: book
:encoding: UTF-8
:lang: zh-CN
:numbered: 编号
:stem: latexmath
:icons: font
:source-highlighter: coderay
:sectnums:
:sectlinks:
:toc: left
:toc-title: 面试汇总
:sectnumlevels: 3
:toclevels: 2

[perfer]
== 前言

.大纲
. 自我介绍
. 项目介绍
. Java
. Java Web
. Spring 全家桶
. 微服务
. 数据库
. 消息队列
. 其他中间件

本文主要是对面试中常见的问题进行比较全面的总结

.缺点
. 项目介绍不够完善, 缺少亮点介绍
. mysql调优策略不够全面, 缺少实践
. 你对自己的未来计划是什么?
. 你有什么想问我的?

== 自我介绍


.自我介绍
****
主要是介绍自己的背景、擅长的技术栈、项目经历等. 大概控制在3分钟左右, 这样面试官就能有更多时间来了解你.
****

.未来规划
****

****


== 项目介绍

.项目介绍模板
****
. 项目背景
. 项目技术栈
. 你所做的工作, 以及你觉得的亮点
. 项目难点
****


.文件加解密权限管理系统
****
这是我在中软国际公司的项目.
.功能：
. 核心功能是对一个文件进行加密。流程是：先将文件上传到文件存储中间件S3，然后把访问地址和用户所需信息，传给后台，然后后台获取访问文件地址等信息，对其进行加密处理，将加密后的文件上传到文件存储器S3中，并删除原文件。
. 另外一个核心功能是，文件解密。首先用户上传的文件，可能会被任何人访问。然后我们要解决的是用户访问的文件是否有权限查看或编辑等功能。大致流程是：一个用户访问文件1，后然对其进行权限验证, 对有权限访问的用户, 进行解密, 并返回解密后的文件给用户.
. 另外就是一些后台功能: 例如系统的认证及鉴权功能管理功能, 当时就采用``Spring Security + token``方式进行管理

.责任
. 我主要负责文件管理模块功能的开发工作, 并主要负责后台权限管理功能; 并负责服务通过``nginx``搭建集群环境等工作, 并配置限流等工作

.技术栈:
- `nacos` + `spring boot` + `mybatis` + `mysql` + `redis` + `minio`

.项目难点:

****

.[.line-through]#自研量化交易系统#
====
. 该系统主要是为了解决某交易市场量化交易的问题, 并该系统主要框架采用了``spring Boot + JDK21 + mongo``等框架.
该系统主要功能是通过实现的技术指标策略+配置对市场数据进行分析并预测是市场的涨跌情况, 然后根据``下单配置``进行决策是否下单, 或者通过邮箱通知给用户; 其次就是实现模拟器功能, 用于通过处理历史数据来验证``策略配置``可靠性问题, 并根据模拟器的结果来调整策略配置.
基于上诉功能, 实现了半自动化测试功能, 功能主要是对所有配置的可能参数值列举出来并进行排列组合, 然后进行较为全面的测试.
. 项目遇到的问题:
- 1. 由于半自动测试的功能生成的任务是百万甚至千万级别的, 单机跑任务效率太慢, 目前单机性能大概是每天10万个任务(每个任务大概需要6秒完成), 导致测试周期较长.
====

.自动化仓储管理系统
====
这是我在杭州壹悟科技有限公司的第一个项目.

.功能:
. 核心功能有: 管理仓库存储信息, 并通过调度AGV牵引车完成订单任务的调度功能. 主要流程就是: 同步上游系统订单信息, 后台根据收到的订单信息, 调度AGV去相应的库位, 取到需要的容器, 最重搬运到指定位置, 并完成对应的订单任务.
. 其他管理功能: 认证鉴权功能, 但是是自己实现的一套逻辑, 主要是采用``token``方式实现认证过程, 并且自定义实现通过过滤请求的URL, 判断用户是否有权限访问该请求. 另外还有一些后台管理功能, 例如: 订单管理, 容器管理, 库位信息管理等.

.技术栈:
- `nacos` + `spring boot` + `jpa` + `mysql` + `redis` + `kafka`

.项目难点:
* 项目中的数据量比较大, 对资源数据的可视化查询展示影响较大, 通过类似滑动窗口的方式, 对数据进行缓存以及最新动碰时间参数, 从而减少对数据库的查询次数和计算成本, 从而提高了查询效率.
* 崩溃恢复功能: 由于AGV牵引车的不确定性, 时常会出现意外的情况, 例如: 遇到意外的障碍物, 机械故障, 存储信息与实际信息不符导致AGV取到空从而导致意外情况. 我们需要针对这些意外的情况进行处理.
. 遇到意外的障碍物: 一般这个情况下, 我们会给车辆设置一个前方障碍检查功能, 如果出现障碍物就对AGV进行急停处理, 进入异常状态, 并通知管理员, 并进行人工处理.
. 任务恢复: 如遇到当前正在执行任务的AGV出现故障, 无法继续完成任务. 我们这时会重新计算任务, 并重新分配任务, 派出新的AGV去完成任务.

====

.[.line-through]#QA自动化测试平台#
====
这是我在杭州壹悟科技有限公司的第二个项目.

. 该项目主要采用了Spring boot 单体架构, 数据库采用mysql, 和JPA框架, 并整合Jenkins进行自动化部署功能.
该项目主要是解决公司内部多项目管理的问题, 通过对项目进度信息, 提测信息, 以及发现的BUG等信息进行统一管理, 从而提高了项目的开发效率和质量; 并且通过整合Jenkins API, 实现了自动化部署功能, 从而提高了项目的部署效率.
. 我主要负责自动化部署功能的开发工作, 主要通过调用Jenkins的API.
====

=== 项目中遇到的问题

.项目中遇到的问题
. 项目架构设计
. JVM调优问题
. 数据库优化问题
. 项目中的性能问题


==== 项目架构设计

.项目架构设计
====
该项目主要采用了微服务架构设计, 通过整合``cloud alibaba``的组件实现环境的搭建 通过``gateway``进行网关路由.
通过``SkyWalking``进行服务的监控, 分布式事务是通过``Seata``的``TCC``模式实现的.
====

.为什么采用``Seata``的``TCC``模式?
====
针对自动化仓储项目来说, 由于涉及的业务场景问题, 例如: 调用失败接口后并不只是会滚那么简单, 更多的是需要通知到管理员异常信息, 需要额外的处理.
所以采用``TCC``模式, 可以更好的解决这个问题.
====

.``SkyWalking``进行服务的监控, 你们如何使用的? 做了什么优化?
====
我们主要是通过``SkyWalking``进行服务的监控, 通过``SkyWalking``可以监控到服务的调用链, 从而可以更好的定位问题. 能更快的帮助我们定位每个服务和组件的性能瓶颈, 从而提高开发效率. 例如过监控到业务调度服务的查询数据时间过长, 并定位到时mysql的查询时间过长, 通过对sql语句的相关优化, 从而提高了查询效率.
====

==== JVM调优问题

.JVM调优问题
====

====

==== 数据库优化问题

.数据表结构优化问题
====
. 仓储系统在最初设计的时候, 是没有定义好库位和容器的相关标准的.
所以在设计之出是多种库位和多种容器表(一种车, 一个库位表), 在实际的业务场景中, 会出现多种不便利, 例如, 统计查询, 容器转移时需要操作多张表; 其次是如果再出现一种车型就需要再加多张表, 这个会增加开发的成了; 还有如果需要对库位和容器进行升级(例如之前的容器只有一个格口, 现在可以有多个), 这样的话会增加开发成本.
. 为了解决这个问题, 我们开始对库位和容器进行了标准化, 并且对库位和容器进行了合并和升级, 用``type``来区分不同类型库位和容器, 从而减少了表的数量, 从而提高业务的开发效率.
====

.索引优化问题
====
. 首先要明白, 创建索引, 本质上就是创建一个新文件, 记录``索引值``与``主键值/数据地址``的对应关系.
所以创建索引的本质就是牺牲一定的编辑数据(增删改)的性能, 来提高查询数据的性能.
因此不是索引越多越好, 而是要根据业务场景来创建索引.
因此在创建索引时应该需要考虑: 数据量、查询频率、查询条件、排序条件、增删改性能等问题.
. 例如, 在仓储系统中, 有一张任务记录表, 记录了任务个关键信息和状态, 但在查询的过程中发现, 这个状态字段查询非常频繁, 但没有创建索引, 因为最初考虑的时候, 认为改字段数据Lisa行
====

==== 项目中的性能问题

== Java基础

=== 基础面试题

.https://www.processon.com/view/link/64d237f6f136581c9f18f7e9[Java基础-网络地址]
. 面向对象和面向过程的区别
. Java的基本数据类型
. 标识符的命名规则
. instanceof关键字的作用
. 重载和重写的区别
. 介绍下内部类
. 介绍下Java中的四种引用
. HashCode的作用
. 有没有可能两个不相等的对象有相同的hashcode
. 深拷贝和拷贝
. 传值和传引用的区别，Java是怎么样的，有没有传值引用? 基础类型都是传值
. 介绍下Java中的四种引用
. 异常机制, 会影响性能吗
. JDK8、17新特性

==== 面向对象和面向过程的区别

*面向过程(OOP)*：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发

*面向对象(AOP)*：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。

==== Java的基本数据类型

|===
|基本类型 |大小(字节) |默认值 |封装类

|byte | 1/8 字节 |(byte)0 |Byte
|short |2 |(short)0 |Short
|int |4 |0 |Integer
|long |8 |0l |Long
|float |4 |0.0f |Float
|double |8 |0.0d |Double
| boolean | 1/8 字节 | false | Boolean
| char | 2 | \u0000(null) | Character
|===

==== 介绍下内部类

目的：提高安全性

在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这三种：成员内部类、局部内部类、匿名内部类，如下图所示：

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/8968036e5ec5472aa32090fa2260eb0a.png[image.png]

==== 介绍下Java中的四种引用

* *强引用* &emsp;&emsp;强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用 方式：

[source,java]
----
String str = new String("str");
System.out.println(str);
----

* *软引用* &emsp;&emsp;软引用在程序内存不足时，会被回收，使用方式：

[source,java]
----
// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，
// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T
SoftReference<String> wrf = new SoftReference<String>(new String("str"));
----

&emsp;&emsp;

可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。 * *弱引用* &emsp;&emsp;弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：

[source,java]
----
WeakReference<String> wrf = new WeakReference<String>(str);
----

&emsp;&emsp;

可用场景： Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。

*虚引用* &emsp;&emsp;虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意哦，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用例子：

[source,java]
----
PhantomReference<String> prf = new PhantomReference<String>(new String("str"),
new ReferenceQueue<>());
----

&emsp;&emsp;

可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效
&emsp;&emsp;上诉所说的几类引用，都是指对象本身的引用，而不是指Reference的四个子类的引用(SoftReference等)。

==== 异常机制, 会影响性能吗

异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。   仅在异常情况下使用异常；在可恢复的异常情况下使用异常；尽管使用异常有利于 Java 开发，但是在应用中最好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。

=== JUC

.常见面试题
. 线程的特点, 于进程之间的关系
. 多线程状态
. 线程中的常用方法, 以及线程所处状态、锁释放状态问题
. 线程间通信工具类
. 谈谈ThreadLocal的理解
. 线程池7个参数

.锁机制
. ReentrantLock（AQS原理）原理，以及 Condition 的原理
. synchronized锁升级过程

.集合
* 谈谈你对集合的理解
* HashMap的源码: 红黑树;扩容机制, 为什么时2的幂？ 与HashTable有什么区别？还有ConcurrentHashMap？
* ArrayList和LinkedList的区别
* 说说什么是 fail-fast？
* 你了解哪些同步容器？
* CopyOnWrite 怎么保证线程安全，为什么这么做？
* ConcurrentHashMap在红黑树的读写并发会发生什么？

.多线程实战问题
. 一般就是你针对大致业务和Tomcat或者一些中间件的线程池如何配置的，然后在压测的时候，你都查看什么指标？

==== 线程的特点, 于进程之间的关系

.线程的特点
. 线程是进程的一部分, 是CPU调度的基本单位
. 线程是轻量级的进程, 一个进程可以包含多个线程, 一个线程可以包含多个线程

.进程的特点
. 进程是操作系统资源分配的基本单位
. 进程是独立的, 一个进程之间不会相互影响


.线程安全基本特性
. 原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
. 可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。
. 有序性，是保证线程内串行语义，避免指令重排等。

==== 多线程状态

.多线程状态
. ``NEW``: 新建状态, 通过``new``关键字创建线程, 还没有调用``start``方法
. ``RUNNABLE``: 运行状态, 通过``start``方法, 线程进入``RUNNABLE``状态, 等待CPU调度
. ``BLOCKED``: 阻塞状态, 线程调用``synchronized``关键字, 等待锁资源
. ``WAITING``: 等待状态, 线程进入``WAITING``状态, 例如线程调用``wait``方法, 线程调用``park``方法, 等待唤醒
. ``TIMED_WAITING``: 超时等待状态, 线程进入``TIMED_WAITING``状态, 例如线程调用``sleep``方法, 线程调用``join``方法, 线程调用``park``方法, 等待唤醒, 但是有超时时间
. ``TERMINATED``: 终止状态, 线程进入``TERMINATED``状态, 线程执行完毕, 或者线程抛出异常, 或者线程调用``stop``方法

==== 线程中的常用方法

. `start()`: 启动线程.
. `run()`: 执行具体实现的方法体.
. `getName()`: 获取当前线程名.
. `priority`: 优先级, 线程优先级, 范围1~10. 但是这个优先级并不是绝对的, 而只是一个参考因数.
因为CPU调度是一个很复杂的程序, 需要考虑很多因素.
. `isAlive()`: 判断线程是否存活.
. `join()`: 等待线程执行完毕.

==== 线程间通信工具类

.线程间通信工具类
. ``wait``和``notify``方法
- `wait`: 使线程暂停, 并释放锁, 直到被唤醒
- `notify`: 唤醒一个正在等待该对象的线程. 如果有多个线程在等待, 则只唤醒一个, 需要调用``notigyAll()``
. ``CountDownLatch``类: 可以让一组线程等待, 直到其他线程执行完毕, 再执行
. ``CyclicBarrier``: 循环栅栏, 可以让一组线程等待, 直到到达栅栏位置, 然后一起执行
. ``Semaphore``类: 信号量, 可以控制同时访问的线程个数
. ``Exchanger``类: 交换器, 可以让两个线程交换数据
. ``Phaser``类: 阶段器, 可以让一组线程等待, 直到其他线程执行完毕, 再执行

==== 谈谈ThreadLocal的理解

image::https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/b4f18c4a52ce4b2aa5cd2abfa9d46d4f.png[ThreadLocal结构图]

.谈谈ThreadLocal的理解
****
. 首先ThreadLocal是一个线程本地变量, 也就是说每个线程都有自己的ThreadLocal变量, 互不干扰
. ThreadLocal的作用: 通过ThreadLocal, 可以在每个线程中存储自己的变量, 从而实现线程间的数据隔离
. ThreadLocal的使用场景: 例如数据库连接, 通过ThreadLocal, 可以在每个线程中存储自己的数据库连接, 从而实现数据库连接的复用
. ThreadLocal的原理: ThreadLocal是通过``ThreadLocalMap``实现的, 每个线程都有自己的``ThreadLocalMap``对象, 通过``ThreadLocalMap``对象, 可以存储自己的变量, 从而实现线程间的数据隔离
****

==== 线程池7个参数

. 核心线程数
. 最大线程数
. 空闲线程存活时间
. 时间单位
. 任务队列
. 拒绝策略
. 线程工厂

.工作原理:
. 先交给核心线程,
. 如果核心线程满了, 则交给任务队列,
. 如果任务队列满了, 则交给最大线程数,
. 如果最大线程数满了, 则执行拒绝策略

==== 锁机制

. AQS锁
. ``synchronized``锁
. `ReentrantLock` 和 `Condition` 锁的使用, 并实现生产消费模式

==== AQS原理

`volitile` state + CAS + 自旋锁 + LockSupport 支持阻塞和唤醒线程

==== synchronized锁升级过程

.synchronized锁升级过程
. 偏向锁: 通过CAS, 将对象头中的mark word修改为偏向锁, 然后将线程id写入到对象头中的mark word中
. 自旋锁: 如果出现锁竞争, 则通过CAS, 将对象头中的mark word修改为自旋锁, 然后通过自旋锁, 不断的尝试获取锁
. 重量级锁: 如果自旋锁获取锁失败, 则通过CAS, 将对象头中的mark word修改为重量级锁.
然后向系统申请锁资源

==== 集合

.集合常见面试题
* 谈谈你对集合的理解
* HashMap的源码: 红黑树;扩容机制, 为什么时2的幂？ 与HashTable有什么区别？还有ConcurrentHashMap？
* ArrayList和LinkedList的区别
* 说说什么是 fail-fast？
* 你了解哪些同步容器？

===== 谈谈你对集合的理解

.谈谈你对集合的理解
****
. 首先集合使用存储一组数据, 集合是一个设计思想, 而数组和链表是集合的具体实现
. 针对集合, jdk给我们默认提供了两大接口: ``Collection``和``Map``接口
. ``Collection``集合存储一组数据
. ``Map``集合存储一组键值对, 方便通过键获取值
. ``Collection``接口下有两个子接口: ``List``和``Set``以及队列``Queue``接口
.. ``ArrayList``和``LinkedList``是``List``接口的两个实现类java, 主要用于存储一组有序的数据
.. ``HashSet``和``TreeSet``是``Set``接口的两个实现类, 主要用于存储一组无序的数据, 起到去重的作用
.. ``Queue``接口主要用于存储一组有序的数据, 并且可以进行出队和入队操作.
当然有些实现阻塞队列, 实现生产消费模式
. ``Map``接口下有两个子接口: ``HashMap``和``TreeMap``以及``ConcurrentHashMap``接口
.. ``HashMap``和``TreeMap``是``Map``接口的两个实现类, 主要用于存储一组键值对, 方便通过键获取值
.. ``ConcurrentHashMap``是``Map``接口的一个实现类, 主要用于存储一组键值对, 方便通过键获取值, 并且是线程安全的.
通过分段锁的方式, 提高了并发性能, 也就是锁定数组中的某个位置, 从而达到线程安全的目的, 不影响其他线程操作其他位置的数据
****

===== HashMap实现原理. 线程不安全的隐患

HashMap的源码. 扩容机制, 为什么时2的幂？ 与HashTable有什么区别？还有ConcurrentHashMap？

.扩容机制
****
. 扩容机制: 当HashMap的容量达到``threshold``的时候, 就会进行扩容, 扩容的大小为原来的两倍
. 为什么是2的幂: 为了提高hash值的散列性, 有利于计算
. 线程不安全的隐患: 可能会缺少值, 例如线程A和线程B同时进行扩容, 线程A扩容的时候, 将原来的数据复制到新的数组中, 线程B扩容的时候, 将原来的数据复制到新的数组中, 线程A和线程B都将原来的数据复制到新的数组中, 但是线程B的数据会覆盖线程A的数据, 从而导致数据丢失
****
// 例如``hash(key) = key.hashCode() & (length - 1)``, 如果length是2的幂, 那么``hash(key) = key.hashCode() & (length - 1)``就等价于``hash(key) = key.hashCode() % length``


===== HashTable实现原理

方法级别的锁, 线程安全, 但是效率低下

===== ConcurrentHashMap实现原理

. 首先通过CAS, 将数据存储到``table``数组中
. 如果发生了hash冲突, 则通过``synchronized``关键字, 锁住当前数组所在位置的对象, 将数据存储到``table``数组中

=== IO, 网络IO 【TODO】

. OSI七层和TCP/IP四层模型
. 谈谈你对Java IO 模型的理解
. IO的设计模式
. BIO, NIO, 多路复用器

. HTTP、TCP、Socket的关系是什么？
. HTTP的长链接和短连接的区别
. Cookie和session的区别
. TCP三次握手, 为什么需要三次?
. TCP四次挥手, 为什么需要四次?

. Netty

==== OSI七层和TCP/IP四层模型

为了更好地促进互联网的研究和发展，国际标准化组织ISO在1985 年指定了网络互联模型。OSI 参考模型（Open System Interconnect Reference https://so.csdn.net/so/search?q=Model&spm=1001.2101.3001.7020[Model]），具有 7 层结构

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/8b05a5e5ca8f45f6adfe5a2473797a6e.png[image.png]

*应用层*：各种应用程序协议，比如HTTP、HTTPS、FTP、SOCKS安全套接字协议、DNS域名系统、GDP网关发现协议等等。
*表示层*：加密解密、转换翻译、压缩解压缩，比如LPP轻量级表示协议。
*会话层*：不同机器上的用户建立和管理会话，比如SSL安全套接字层协议、TLS传输层安全协议、RPC远程过程调用协议等等。

*传输层*：接受上一层的数据，在必要的时候对数据进行分割，并将这些数据交给网络层，保证这些数据段有效到达对端，比如TCP传输控制协议、UDP数据报协议。
*网络层*：控制子网的运行：逻辑编址、分组传输、路由选择，比如IP、IPV6、SLIP等等。
*数据链路层*：物理寻址，同时将原始比特流转变为逻辑传输路线，比如XTP压缩传输协议、PPTP点对点隧道协议等等。
*物理层*：机械、电子、定时接口通信信道上的原始比特流传输，比如IEEE802.2等等。

而且在消息通信的过程中具体的执行流程为：

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/62a425220acc40b6b53cf2c34a4331a6.png[image.png]

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/933af2e7173942319f49900f5ce9ae49.png[image.png]

网络传输的数据其实会通过这七层协议来进行数据的封装和拆解

==== 谈谈你对Java IO 模型的理解

https://www.processon.com/view/link/64a8d8d01906b3205606463f[IO详细完整笔记]

* 首先IO是指输入输出，是计算机与外部设备或者是用户之间的交互方式, 例如磁盘数据的读取, 网络数据的传输等这些行为都是IO行为
* 常见的IO模型有三种: BIO, NIO, 多路复用器; 当然还有AIO, 但是目前linux还没有实现, 所以目前先不考虑
** BIO: 简单来说是一个阻塞型IO, 在读取数据的时候需要等待数据读取完成才能进行下一步操作
** NIO: 简单来说是一个非阻塞型IO, 在读取数据的时候不需要等待数据读取完成, 可以进行下一步操作, 但是需要不断的轮询数据是否读取完成
** 多路复用器: 简单来说是一个非阻塞型IO, 在读取数据的时候不需要等待数据读取完成, 可以进行下一步操作, 但是不需要不断的轮询数据是否读取完成, 而是通过操作系统的多路复用器, 例如epoll, kqueue等, 通过事件驱动的方式, 当数据读取完成之后, 通过回调的方式通知程序, 然后程序再进行下一步操作
** AIO: 简单来说是一个异步非阻塞型IO, 在读取数据的时候不需要等待数据读取完成, 可以进行下一步操作, 但是不需要不断的轮询数据是否读取完成, 而是通过操作系统的多路复用器, 例如epoll, kqueue等, 通过事件驱动的方式, 当数据读取完成之后, 通过回调的方式通知程序, 然后程序再进行下一步操作

https://www.processon.com/view/link/64d352e1f136581c9f1a72a6[IO模型]

==== IO的设计模式

==== TCP三次握手

.三次握手的过程
. 客户端发送一个SYN包
. 服务端接收到之后, 返回一个SYN+ACK包
. 客户端接收到之后, 返回一个ACK包, 这样就完成了三次握手

.三次握手的原因
为了双方都能确认对方的接收能力和发送能力, 从而保证数据的可靠传输

==== TCP为什么需要三次, 而不是两次?

如果有两次握手的话, 过程如下: 客户端发送一个SYN包, 服务端接收到之后, 返回一个SYN+ACK包, 并立即进入ESTABLISHED状态, 但是客户端并不知道服务端是否接收到了SYN+ACK包, 所以客户端并不知道服务端的接收能力和发送能力, 从而无法保证数据的可靠传输

==== TCP四次挥手

.四次挥手的过程
. 客户端发送一个FIN包, 请求关闭连接.
. 服务端接收到之后, 返回一个ACK包.
这时服务端可能还会有数据要发送给客户端, 所以服务端不会立即关闭连接, 而是等待数据发送完成之后, 再发送一个FIN包
. 服务端发送一个FIN包.
等数据都发送完之后, 服务端发送一个FIN包, 请求关闭连接.
. 客户端接收到之后, 返回一个ACK包, 这样就完成了四次挥手.

==== TCP为什么需要四次, 而不是三次?

.如果有三次挥手的话, 过程如下:
. 客户端发送一个FIN包, 请求关闭连接.
. 服务端接收到之后, 返回一个ACK包.
这时服务端可能还会有数据要发送给客户端, 所以服务端不会立即关闭连接, 而是等待数据发送完成之后, 再发送一个FIN包
. 服务端发送一个FIN包.
等数据都发送完之后, 服务端发送一个FIN包, 请求关闭连接.

==== Netty

详细参考: https://www.processon.com/diagraming/65eefc0b66ca8e5b47d982fb[Netty详细笔记]

.常见面试题
. 谈谈你对Netty的理解
. Netty的线程模型
. Netty的粘包拆包问题
. Netty的心跳机制
. Netty的零拷贝机制
. Netty的内存池化机制
. Netty的高性能和高可用原因
. Netty连接计数实现

.谈谈你对Netty的理解
====
. Netty是一个基于NIO的网络通信框架, 通过Netty可以快速的开发出一个高性能的网络通信程序
. Netty的核心组件有五个: Channel, EventLoop, ChannelFuture, ChannelHandler, ChannelPipeline
. Channel: 通道, 用于数据的传输, 例如客户端和服务端的连接, 通过通道进行数据的传输
. EventLoop: 事件循环, 用于处理连接的事件, 例如连接的建立, 连接的关闭, 数据的读取, 数据的写入等
. ChannelFuture: 用于异步通知, 例如连接的建立, 连接的关闭, 数据的读取, 数据的写入等
. ChannelHandler: 用于处理数据的读写, 例如数据的编码, 数据的解码, 数据的处理等
. ChannelPipeline: 用于管理ChannelHandler, 例如添加ChannelHandler, 删除ChannelHandler, 替换ChannelHandler等
====

.Netty的线程模型
====
. Netty的``Reactor``线程模型有三种: 单线程模型, 多线程模型, 主从多线程模型
* 单线程模型: 一个线程处理所有的连接, 一个线程处理所有的连接事件, 一个线程处理所有的数据读写
* 多线程模型: 一个线程处理所有的连接, 多个线程处理所有的连接事件, 多个线程处理所有的数据读写
* 主从多线程模型: 一个线程处理所有的连接, 多个线程处理所有的数据读写, 一个线程处理所有的数据读写
. 三种线程模型的优缺点
** 单线程模型: 优点: 简单, 缺点: 性能低
** 多线程模型: 优点: 性能高, 缺点: 复杂
** 主从多线程模型: 优点: 性能高, 缺点: 复杂
====

.Netty的心跳机制
====
.
====

=== JVM

.常见面试题
. JDK、JRE与JVM的区别
. 为什么需要JVM?
谈谈你对JVM的理解
. 类加载机制, 类加载器的层次
. 双亲委派机制. 如何打破双亲委派?
. JVM 的主要组成部分及其作用？(JMM模型)
. Java程序运行机制步骤
. 堆栈的区别
. 常量池分类
. 访问对象有哪几种方式: 指针, 句柄
. 对象的生命周期可以描述一下吗
. 你能聊一聊对象模型的对齐填充设计原因吗？
. 聊一聊对象的内存分配过程
. 为什么需要两个Survivor区？
. 堆内存中都是线程共享的区域吗？
. 方法区与元数据区以及持久代到底是什么关系
. 栈帧结构是什么样子的？

.垃圾回收器常见面试题
. 如何确定一个对象是垃圾？
. 垃圾收集算法
. 什么是STW（stop the world）？
. 谈谈三色标记算法
. 垃圾收集器
. 记忆集和卡表
. JVM常见的参数, 常用命令

.JVM调优问题
. 说说都有哪些场景可能导致``OOM``?
. JVM常用命令有哪些，你是怎么使用的
. JVM常用参数以及垃圾收集器常见参数
. JVM自带的可视化工具有哪些
. **GC**预估, 以及怎么调优
. 内存分配
. 常见内存分析: 超大对象, 超过预期访问量, 过多使用Finalizer, 内存泄漏, 长生命周期的对象持有短生命周期对象的引用, 连接未关闭, 变量作用域不合理, Hash值改变

==== JDK、JRE与JVM的区别

JVM只是一个翻译，把Class翻译成机器识别的代码，但是需要注意，JVM 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到JRE。

JRE是什么，它除了包含JVM之外，提供了很多的类库（就是我们说的jar包，它可以提供一些即插即用的功能，比如读取或者操作文件，连接网络，使用I/O等等之类的）这些东西就是JRE提供的基础类库。JVM 标准加上实现的一大堆基础类库，就组成了 Java 的运行时环境，也就是我们常说的 JRE（Java Runtime Environment）。

但对于程序员来说，JRE还不够。我写完要编译代码，还需要调试代码，还需要打包代码、有时候还需要反编译代码。所以我们会使用JDK，因为JDK还提供了一些非常好用的小工具，比如 javac（编译代码）、java、jar （打包代码）、javap（反编译<反汇编>）等。这个就是JDK。

==== 为什么需要JVM? 谈谈你对JVM的理解

首先JVM是Java虚拟机的简称, 可以帮助我们屏蔽底层的操作系统的差异, 使得我们可以在不同的操作系统上运行Java程序, 从而实现了Java的跨平台性.
可以运行``Class``文件

==== 类加载机制, 类加载器的层次

.类加载机制
image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1463/1644577518000/b5ec599f1b8242a19cb6995a97cb02cf.png[类加载机制]

. 装载: Class文件 -> 二进制字节流 -> java中的寻找器（类加载器）
. 链接: 对于二进制字节流进行验证, 准备, 解析
** 验证: 验证二进制字节流是否符合JVM规范
** 准备: 为静态变量分配内存, 并初始化默认值
** 解析: 将符号引用转换为直接引用
. 初始化: 执行到``Clinit``方法, 为静态变量赋值, 初始化静态代码块, 初始化当前类的夫类
. 使用: 创建对象(new, 反射, 克隆, 反序列化).(调用构造方法创建对象)
. 卸载: 类信息从方法区中移除.
但是目前只有自定义的类加载器才能卸载.

.类加载器的层次
. ``BootStrap``启动类加载器: 加载``JAVA_HOME/jre/lib``目录下的类库, 例如``rt.jar``, ``charsets.jar``等
. 扩展类加载器: 加载``JAVA_HOME/jre/lib/ext``目录下的类库, 例如``ext``目录下的类库
. 应用程序类加载器: 加载用户类路径上的类库, 例如``classpath``下的类库
. 自定义类加载器: 用户自定义的类加载器, 例如``tomcat``中的类加载器

==== 双亲委派机制, 如何打破?

双亲委派机制的核心是: 向上检查，向下委派.
具体指的是通过类的全限定名, 从应用程序类加载器或者自定义类加载器开始, 依次向上委派, 直到启动类加载器, 如果启动类加载器加载不了, 则向下委派, 依次向下委派, 直到应用程序类加载器, 如果应用程序类加载器加载不了, 则抛出``ClassNotFoundException``异常

.打破双亲委派机制的方式有三种:
. 通过继承``ClassLoader``类, 重写``loadClass``方法, 在方法中通过``findClass``方法, 加载自定义的类, 从而打破双亲委派机制
. 通过``SPI``机制, 例如``JDBC``的驱动加载机制, 通过``ServiceLoader``类, 通过``Thread.currentThread().setContextClassLoader()``方法, 将当前线程的上下文类加载器设置为自定义类加载器, 从而打破双亲委派机制
. ``OSGI``机制, 通过``Bundle``类, 通过``BundleContext.installBundle()``方法, 将自定义的类加载器注册到``OSGI``容器中, 从而打破双亲委派机制.
常用来进行解决热部署.

==== JVM 的主要组成部分及其作用？

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1660195887078/70c416b3a15c4629886e45cfab0e87f6.png[JMM模型]

JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。

. Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到``Runtime data area``中的``method area``。
. `Execution engine`（执行引擎）：执行classes中的指令。
. `Native Interface`(本地接口)：与native libraries交互，是其它编程语言交互的接口。
. `Runtime data area`(运行时数据区域)：这就是我们常说的JVM的内存。 作用 ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。
* `方法区`: 用于存储类的信息, 例如类的全限定名, 类的修饰符, 类的常量池, 类的字段, 类的方法, 类的构造方法, 类的静态变量, 类的静态代码块, 类的非静态变量, 类的非静态代码块, 类的非静态方法, 类的父类, 类的接口等
* `堆`: 用于存储对象, 例如通过``new``关键字创建的对象, 通过``clone``方法创建的对象, 通过``反序列化``创建的对象, 通过``反射``创建的对象, 通过``数组``创建的对象等
* `栈`: 用于存储局部变量, 例如方法的参数, 方法的局部变量, 方法的返回值等
* `本地方法栈`: 用于存储本地方法, 例如通过``native``关键字修饰的方法
* `程序计数器`: 用于存储当前线程执行的字节码的行号
* `直接内存`(不重要): 用于存储对象, 例如通过``DirectByteBuffer``创建的对象

==== Java程序运行机制步骤

首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java； 再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class； 运行字节码的工作是由解释器(java命令)来完成的。

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1463/1646137467048/a2b57e0612a0461dbd4ad1dfb42a6eca.png[image.png]

从上图可以看，java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。 其实可以一句话来解释：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。

==== 堆栈的区别

==== 常量池分类

.常量池分类(是在方法区)
. `静态常量池`: 存放类的常量, 例如类的静态变量, 类的静态代码块, 类的静态方法, 类的常量池等
. `运行时常量池`: 存放对象的常量, 例如对象的非静态变量, 对象的非静态代码块, 对象的非静态方法, 对象的常量池等
. `字符串常量池`: 存放字符串常量, 例如通过``new``关键字创建的字符串, 通过``intern``方法创建的字符串, 通过``字面量``创建的字符串等

==== 访问对象有哪几种方式: 指针, 句柄

m TODO, 先不写

==== 对象的生命周期可以描述一下吗

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1650279430028/01c7a2f4dd3a4593bca61e1c89fc5d4b.png[对象的生命周期]

.对象的生命周期可以分为四个阶段: 创建, 使用, 不可见, 回收
. 创建: 通过``new``关键字创建对象, 通过``clone``方法创建对象, 通过``反序列化``创建对象, 通过``反射``创建对象, 通过``数组``创建对象等
. 使用: 对象的方法, 对象的属性, 对象的常量池等
. 不可见: 对象的引用被置为``null``, 对象的引用被赋值给其他对象, 对象的引用超出了作用域等
. 回收: 对象的引用被置为``null``, 对象的引用被赋值给其他对象, 对象的引用超出了作用域等

==== 你能聊一聊对象模型的对齐填充设计原因吗？

.对象模型的对齐填充设计原因
Java对象的占用空间包括对象头、实例数据以及对齐填充。具体占用多少字节会受到JVM的实现、JVM参数、对象的字段及其类型等因素的影响。

. 对象头（Object Header）： 典型的对象头大小在64位的HotSpot虚拟机中占用12-16个字节。其中，Mark Word（标记字）占用8字节，Class Metadata（类元数据指针）占用4-8字节，具体大小取决于压缩指针的使用情况
. 实例数据（Instance Data）： 实例数据的大小取决于对象的字段及其类型。每个字段占用的字节数由字段的类型和对齐方式决定。例如，int类型字段占用4字节，long类型字段占用8字节。
. 对齐填充（Padding）： JVM要求对象的起始地址必须是8字节的整数倍（在某些平台上可能是4字节的整数倍），因此可能需要对齐填充来满足这个要求。

综合考虑以上因素，一个Java对象的占用空间可以通过以下公式估算：

对象占用空间=对象头大小+实例数据大小+对齐填充

对齐填充的意义是 *提高CPU访问数据的效率* ，主要针对会存在**该实例对象数据跨内存地址区域存储**的情况。

==== 聊一聊对象的内存分配过程

.对象的内存分配过程
. 对象一般从Eden区创建
. 如果Eden区没有足够的空间创建对象, 则会触发一次Minor GC, 将Eden区中的存活对象复制到Survivor区的From区, 然后清空Eden区, 然后将创建新对象在Eden区
. 直到**内存不足**或者**对象年龄到达一定的阈值**, 例如15岁, 就会去``老年代``
. 如果老年代没有足够的空间创建对象, 则会触发一次Full GC.
如果Full GC之后, 老年代还是没有足够的空间创建对象, 则会抛出``OutOfMemoryError``异常

==== 为什么需要两个Survivor区？

最大的好处就是解决了碎片化.

==== 堆内存中都是线程共享的区域吗？

.堆内存中都是线程共享的区域吗？
.
==== 如何确定一个对象是垃圾？

.对象是垃圾的判定
. 引用计数法: 判断都有引用, 没有引用的为垃圾.
缺点: 无法解决循环引用问题.
. 可达性分析法: 引用出一条单向的引用链，而在这个单向的引用链之上的对象，我们称之为GC的可达对象，不在引用链上的对象 我们称之为垃圾

==== 垃圾收集算法

.垃圾收集算法
. `标记-清除算法`: 标记所有需要回收的对象, 然后统一回收所有需要回收的对象.
缺点: 会产生大量的内存碎片
. `标记-复制算法`: 将内存分为两块, 一块为``From``区, 一块为``To``区, 当``From``区的内存不足时, 将``From``区的存活对象复制到``To``区, 然后清空``From``区, 然后将创建新对象在``From``区.
优点: 效率高.
缺点: 会浪费一半的内存空间.
. `标记-整理算法`: 边标记边清理.

.`标记-清除算法`的衍生规则之分配(动态分区分配策略)
. `首次适应算法`: 从头开始查找, 找到第一个满足大小的空闲分区, 分配给当前对象
. `最佳适应算法`: 从所有的空闲分区中找到最小的空闲分区, 分配给当前对象
. `最差适应算法`: 就是在遍历空闲链表的时候，找出空闲链表中最大的分块，将其分割给申请的对象，其目的就是使得分割后分块的最大化，以便下次好分配，不过这种分配算法很容易产生很多很小的分块，这些分块也不能被使用

[.line-through]## .``标记-整理``基本算法 . 随机整理: 头尾两指针, 头指针找空闲位置, 尾指针找非空闲位置, 交换; 直到头指针与尾指针相遇, 整理结束.
缺点：要求空间大小一致 . 滑动整理: 遍历三次: 第一次, 预留位置; 第二次, 移动对象; 第三次, 清理空间.
缺点：效率低 . 线性整理:

____
既然上面介绍了3中垃圾收集算法，那么在堆内存中到底用哪一个呢？

Young区：复制算法(对象在被分配之后，可能生命周期比较短，Young区复制效率比较高)

Old区：标记清除或标记整理(Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理)
____

==== 增量回收算法

==== 三色标记算法

在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。这里引入“三色标记”来给大家解释下，把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：

. `灰色`: 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。
. `黑色`: 表示对象已经被垃圾收集器访问过， 而且这个对象上的所有引用都已经被扫描过， 这个对象不会再被垃圾收集器扫描到。
. `白色`: 表示对象尚未被垃圾收集器访问过.
显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。


.标记过程
. 初始时, 所有对象都在``白色集合``中;
. 将``GC Roots``直接引用到的对象 挪到``灰色集合``中
. 从灰色集合中获取对象：
.. 将本对象 引用到的 其他对象 全部挪到``灰色集合``中;
.. 将本对象 挪到``黑色集合``里面.
. 重复步骤3.4，直至【灰色集合】为空时结束。

.多标-浮动垃圾
****
在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gc root引用的对象之前又被扫描过 (被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动 垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。

另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分 对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。
****

.漏标-读写屏障
****
.漏标只有同时满足以下两个条件时才会发生
. 条件一：灰色对象 断开了 白色对象的引用；即灰色对象 原来成员变量的引用 发生了变化。
. 条件二：黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。

漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： 增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB） 。

**增量更新**就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。

**原始快照**就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)

以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。

写屏障实现原始快照（SATB）： 当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d = null），我们可以利用写屏障，将B原来成员变量的引用对象D记录下来：

写屏障实现增量更新： 当对象A的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A新的成员变量引用对象D 记录下来：

****

==== 什么是STW（stop the world）？

.是在垃圾回收算法执行过程中,将jvm内存冻结,停顿的一种状态，在Stw情况下，容易出现两种现象：
. 该回收的对象没有被回收
. 不该回收的对象被回收了

在STW状态下, 所有的工作线程都是停止运行的, 但垃圾回收线程除外

当STW发生时, 出了GC所需要的线程,其他的线程都将停止工作,中断了的线程知道GC线程结束才会继续任务

STW是不可避免的,垃圾回收算法的执行一定会出现STW,而我们最好的解决办法就是减少停顿的时间

GC各种算法的优化重点就是为了减少STW,这也是JVM调优的重点。

==== CMS 与 G1 垃圾

.CMS垃圾收集器
. 标记清除算法

==== 常用命令

.常用命令
. `jps [-l]`: 查看当前运行的java进程
. `jinfo [-flag] <name> <PID>`: 查看/修改jvm的配置信息
. `jstat -gcutil <PID> <interval> <count>`: 查看jvm的gc、内存、类加载等信息
. `jmap`: 查看jvm的内存快照信息
. `jstack`: 查看jvm的线程堆栈信息

==== 双亲委派机制. 如何打破双亲委派?

.打破双亲委派机制的方式有三种:
. 通过继承``ClassLoader``类, 重写``loadClass``方法, 在方法中通过``findClass``方法, 加载自定义的类, 从而打破双亲委派机制
. 通过``SPI``机制, 例如``JDBC``的驱动加载机制, 通过``ServiceLoader``类, 通过``Thread.currentThread().setContextClassLoader()``方法, 将当前线程的上下文类加载器设置为自定义类加载器, 从而打破双亲委派机制
. ``OSGI``机制, 通过``Bundle``类, 通过``BundleContext.installBundle()``方法, 将自定义的类加载器注册到``OSGI``容器中, 从而打破双亲委派机制.
常用来进行解决热部署.

==== JVM 的主要组成部分及其作用？(JMM模型)

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1660195887078/70c416b3a15c4629886e45cfab0e87f6.png[JMM模型]

==== Java程序运行机制步骤

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1463/1646137467048/a2b57e0612a0461dbd4ad1dfb42a6eca.png[image.png]

==== 堆栈的区别

==== 常量池分类

.常量池分类(是在方法区)
. `静态常量池`: 存放类的常量, 例如类的静态变量, 类的静态代码块, 类的静态方法, 类的常量池等
. `运行时常量池`: 存放对象的常量, 例如对象的非静态变量, 对象的非静态代码块, 对象的非静态方法, 对象的常量池等
. `字符串常量池`: 存放字符串常量, 例如通过``new``关键字创建的字符串, 通过``intern``方法创建的字符串, 通过``字面量``创建的字符串等

==== 访问对象有哪几种方式: 指针, 句柄

=== JVM 调优案例

. 现场反馈时长调度不来车问题
. 服务突然不接受请求

=== 设计模式

.基础面试题
. 谈谈你对设计原则的理解
. 谈谈你对设计模式的理解

.实战面试题
. 你在项目中使用了哪些设计模式？为什么使用这些设计模式?


==== 设计原则

.谈谈你对设计原则的理解
====
. 首先设计原则是一种设计思想, 通过这种设计思想, 可以使得代码更加的灵活, 更加的易于维护, 以及更加的易于扩展
. 设计原则有很多, 例如: 单一职责原则, 开闭原则, 里氏替换原则, 依赖倒置原则, 接口隔离原则, 迪米特法则等
. 单一职责原则: 一个类只负责一项职责.
例如: 一个类只负责数据库的连接, 一个类只负责数据库的查询, 一个类只负责数据库的更新等
. 开闭原则: 对扩展开放, 对修改关闭.
例如: 通过接口的方式, 通过实现接口的方式, 实现对类的扩展, 而不是修改原有的类
. 里氏替换原则: 子类可以替换父类.
. 依赖倒置原则: 面向接口编程.
. 接口隔离原则: 一个类对另一个类的依赖应该建立在最小的接口上.
====

==== 谈谈你对设计模式的理解

.创建型模式
. 工厂方法模式: 工厂设计模式定义了一个创建对象的接口，但由子类决定要实例化的类。它将实例化的过程推迟到子类.
. 抽象工厂模式: 抽象工厂设计模式提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。它是对一组相关或相互依赖的工厂进行封装.
** 工厂和抽象工厂模式的区别: 工厂模式是一个工厂生产一个产品, 抽象工厂模式是一个工厂生产一组产品;
. 建造者模式: 主要是用于创建一些复杂的对象, 通过一步一步的创建, 最终创建出一个完整的对象.
. 单例模式: 是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点.
. 原型模式: 使你能够复制已有对象， 而又无需使代码依赖它们所属的类.

.结构型模式
. 适配器模式: 它能使接口不兼容的对象能够相互合作.
适配器模式有两种实现方式: 类适配器和对象适配器.
** 类适配器: 实现目标接口和需要适配的类, 并且继承需要适配的类, 通过重写目标接口的方法, 调用需要适配的类的方法, 实现目标接口的方法
** 对象适配器: 实现目标接口, 并将适配器对象传入, 通过调用适配器对象的方法, 实现目标接口的方法


.行为型模式
. 责任链模式: 允许你将请求沿着处理者链进行发送.
收到请求后, 每个处理者均可对请求进行处理, 或将其传递给链上的下个处理者.
. 观察者模式: 它可在对象之间定义一对多的依赖关系, 使得每当一个对象改变状态时, 其相关依赖对象都会收到通知并自动更新.
. 策略模式: 它能让你定义一系列算法, 并将每种算法分别放入独立的类中, 以使算法的对象能够相互替换.

==== 你在项目中使用了哪些设计模式？为什么使用这些设计模式?

.样例
====
. 策略模式: 自己的理解是将某一件行为可能有多种行为, 这时就可以抽象出一个接口和方法, 然后根据不同场景进行实现其中的方法, 然后在需要使用的时候, 直接使用顶级接口方法, 这样就可以根据不同的场景进行创建不同的策略对象.
* 基于仓储项目, 实际开发过程中, 一个站台, 可以做很多模式行为, 例如: 上架、盘点、拣选等模式. 而这些模式都有许多共同点, 都是叫车, 操作, 驱赶车辆等行为. 这时我们把这些共同的行为抽象出一个顶级接口, 然后根据不同场景使用不同的策略对象, 并完成相应的任务.
. 适配器模式: 自己的理解是将一个类的接口转换成客户希望的另外一个接口.

====

== Java Web

.常见面试题
. HTTP响应码常见有哪些？分别代表什么意思？
. Forward和Redirect的区别
. GET和POST的区别
. HTTP和HTTPS的区别
. 说下HTTP、TCP、Socket的关系是什么？
. 说下HTTP的长链接和短连接的区别
. Cookie和Session的区别
. Tomcat是什么?
. 什么是Servlet, Servlet生命周期, 什么是Servlet规范?
. jsp和Servlet的区别
. 九大内置对象
. JSP的四大作用域
. GenericServlet和HttpServlet有什么区别？

=== HTTP响应码常见有哪些？分别代表什么意思？

. 1xx（临时响应）
. 2xx（成功）
. 3xx（重定向）：表示要完成请求需要进一步操作; 301永久重定向, 302临时重定向, 304未修改
. 4xx（错误）：表示请求可能出错，妨碍了服务器的处理. 400客户端请求错误, 401未授权, 403禁止访问, 404未找到
. 5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误

.举例：
* 200：成功，Web服务器成功处理了客户端的请求。
* 301：永久重定向，当客户端请求一个网址的时候，Web服务器会将当前请求重定向到另一个网址，搜索引擎会抓取重定向后网页的内容并且将旧的网址替换为重定向后的网址。
* 302：临时重定向，搜索引擎会抓取重定向后网页的内容而保留旧的网址，因为搜索引擎认为重定向后的网址是暂时的。
* 400：客户端请求错误，多为参数不合法导致Web服务器验参失败
* 404：未找到，Web服务器找不到资源
* 500：Web服务器错误，服务器处理客户端请求的时候发生错误
* 503：服务不可用，服务器停机
* 504：网关超时

=== Forward和Redirect的区别

. 浏览器URL地址：Forward是服务器内部的重定向，服务器内部请求某个servlet，然后获取响应的内容，浏览器的URL地址是不会变化的；Redirect是客户端请求服务器，然后服务器给客户端返回了一个302状态码和新的location，客户端重新发起HTTP请求，服务器给客户端响应location对应的URL地址，浏览器的URL地址发生了变化。
. 数据的共享：Forward是服务器内部的重定向，request在整个重定向过程中是不变的，request中的信息在servlet间是共享的。Redirect发起了两次HTTP请求分别使用不同的request。
. 请求的次数：Forward只有一次请求；Redirect有两次请求。

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/fba756c1b94e439ab2dec986650a7117.png[image.png]

=== HTTP和HTTPS的区别

端口不同：HTTP和HTTPS的连接方式不同没用的端口也不一样，HTTP是80，HTTPS用的是443 消耗资源：和HTTP相比，HTTPS通信会因为加解密的处理消耗更多的CPU和内存资源。 开销：HTTPS通信需要证书，这类证书通常需要向认证机构申请或者付费购买。

. HTTP是超文本传输协议，是用于从WWW服务器传输超文本到本地浏览器的传送协议。HTTPS是在HTTP的基础上加入了SSL层，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
. HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。HTTP是超文本传输协议，是用于从WWW服务器传输超文本到本地浏览器的传送协议。HTTPS是在HTTP的基础上加入了SSL层，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

=== HTTP、TCP、Socket的关系是什么？

* TCP/IP代表传输控制协议/网际协议，指的是一系列协议族。
* HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。
* Socket是TCP/IP网络的API，其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面。对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

.综上所述:
* 需要IP协议来连接网络
* TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。
* HTTP基于TCP协议，所以可以使用Socket去建立一个TCP连接。

=== HTTP的长链接和短连接的区别

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

*短连接* &emsp;&emsp;在HTTP/1.0中默认使用短链接,也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端访问的某个HTML或其他类型的Web资源，如JavaScript文件、图像文件、CSS文件等。当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话.

*长连接* &emsp;&emsp;从HTTP/1.1起，默认使用长连接，用以保持连接特性。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。

=== Cookie和Session的区别

&emsp;&emsp;

cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器.

&emsp;&emsp;

session是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。服务器默认为客户浏览器的cookie中设置sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie包含sessionid，服务器根据传输cookie中的sessionid获取出会话中存储的信息，然后确定会话的身份信息.

. Cookie数据存放在客户端上，安全性较差，Session数据放在服务器上，安全性相对更高
. 单个cookie保存的数据不能超过4K，session无此限制
. session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当 使用cookie。

== Tomcat

.常见面试题
. 缺省端口是多少?
怎么修改?（默认端口）
. 有哪几种``Connector``运行模式(优化)?
. 部署方式, 有哪几种?
. Tomcat的Servlet如何创建的?
. Tomcat如何优化?
. Tomcat的启动流程?
. Tomcat请求处理流程?

=== Tomcat 启动流程

. 首先启动``Bootstrap``类, 通过反射的方式, 启动``Catalina``类
. ``Catalina``首先读取``server.xml``配置文件, 并解析配置文件, 生成``Server``对象, ``Service``对象, ``Connector``对象, ``Engine``对象, ``Host``对象, ``Context``对象, ``Wrapper``对象等
. 然后初始化``Server``组件, 然后根据架构依次初始化``Service``, ``Connector``, ``Engine``, ``Host``, ``Context``, ``Wrapper``等组件, 并修改当前状态为``INITIALIZING``, 初始化完成之后进入``INITIALIZED``状态
* ``Connector``组件初始化, 主要是初始化``EndPoint``以及``Socket``.
默认是NIO.
其中有协议处理器
. 然后调用``Server``的``start``方法, 并依次启动子组件: ``Service``, ``Connector``, ``Engine``, ``Host``, 并修改当前状态为``STARTING``, 启动完成之后进入``STARTED``状态
. 在启动完``Host``组件的时候, 会由``HostConfig``监听器进行多线程加载``Context``, ``Wrapper``等组件
* ``Service``组件启动, 主要是负责启动``Engine``组件, ``监听器``, ``连接器``等组件
* ``Connector``组件启动, 主要是启动一个接收线程, 和一个``Poller``线程, ``Poller``线程主要是处理读写事件

=== Tomcat 请求处理流程

. Tomcat有三种接受请求的方式: NIO, AIO, APR; 默认是NIO网络处理器为例;
. Acceptor线程首先确认是否达到最大请求连接数, 如果达到了线程处于等待状态, 不再接受新的请求, 直到已有的连接处理完成并释放连接数, Acceptor线程开始等待接受请求;
. Acceptor线程等待接受请求, 这个过程是阻塞的. 直到有新的请求到来, 等待新的线程来了之后, 判断同一个地址, 是否是重复请求(1000 ns), 如果是重复请求, 抛出异常并关闭连接;
. 通过基本校验之后将SocketChannel包装到`NioSocketWrapper`中, 并添加缓存字节, 用于存放请求数据, 并将`NioSocketWrapper`添加到`Poller`的同步队列中(注意细节, Buffer对象没有池化, 不能重复利用; Event对象是池化的, 可以重复利用)
. Poller线程, 从队列中获取连接, 并将``SocketChannel``连接 注册读事件进``Selector``中;
. 然后循环处理`Selector`中的事件, 如果有读事件, 然后交给线程池异步进行将数据读取到缓存中.
// 并将/中的事件
. Poller线程主要是处理读写事件;
. 然后将事件的具体处理交给协议处理器, 比如http1.1的协议处理器, 解析参数以及servlet相关标准的req, resp对象
. 然后将处理交给`Engine`, `Host`, `Context`等容器处理, 通过`Pipeline`的方式, 依次调用`Valve`的invoke方法, 依次处理请求;
. 最后``Context``将请求处理交给了``Filter``处理, 最后一个``Filter``交给了servlet处理;

== Mysql

. 事务的特性: 原子性、一致性、隔离性、持久性
. mysql的基础架构
. 谈谈你对mysql的ddl, dml, dcl的了解
. 事务的隔离级别: 读未提交、读已提交、可重复读、串行化
. 存储引擎: InnoDB, MyISAM
. 如何解决数据的读一致性问题
. 索引问题: `B Tree`, `B+Tree`, `Hash索引`
. 索引类型: `普通索引`, `唯一索引`, `主键索引`, `全文索引`
. 日志文件: `Bin Log`, `Redo Log`, `Undo Log`
. 事务提交流程.(SQL执行流程)
. `Buffer pool`: 内存缓存
. 执行计划
. 慢查询
. Mysql调优案例

=== mysql的基础架构

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1463/1644586172000/669ae3899ee842dbbd9c0fd747865f20.png[image.png]

.Mysql基础架构
. `连接器`: 通过``TCP/IP``协议, 连接到``Mysql``服务器, 并进行身份验证, 连接成功之后, 会生成一个``线程ID``, 并且会将连接信息存储到``连接池``中
. `[.line-through]#查询缓存#`: 查询缓存是一个全局的缓存, 用于存储查询的结果, 但是查询缓存的效率不高, 并且容易出现``缓存失效``的问题, 所以默认是关闭的. 8.0版本之后, 已经移除了查询缓存
. `分析器`: 用于分析查询语句, 并生成``解析树``
. `优化器`: 用于优化查询语句, 并生成``执行计划``
. `执行器`: 用于执行查询语句, 并返回结果
. `存储引擎`: 用于存储数据, 并提供数据的增删改查等操作
. `日志`: 用于记录数据的变更, 并提供数据的恢复

=== 谈谈你对mysql的ddl, dml, dcl的了解

.首先这些都是``SQL``语句
. `DDL`: 用于定义数据库对象, 例如表, 索引, 视图, 存储过程, 函数等
. `DML`: 用于操作数据库对象, 例如插入, 更新, 删除等
. `DCL`: 用于控制数据库对象的访问权限, 例如授权, 撤销授权等

.具体的语句如下:
. `DDL`:
- `CREATE`: 创建数据库对象, 例如表, 索引, 视图, 存储过程, 函数等
- `ALTER`: 修改数据库对象, 例如表, 索引, 视图, 存储过程, 函数等
- `DROP`: 删除数据库对象, 例如表, 索引, 视图, 存储过程, 函数等

. `DML`:
- `INSERT`: 插入数据
- `UPDATE`: 更新数据
- `DELETE`: 删除数据

. `DCL`:
- `GRANT`: 授权
- `REVOKE`: 撤销授权
. `DDL`的执行流程

=== 事务的隔离级别

.事务的隔离级别
. 读未提交: 一个事务可以读取另一个事务未提交的数据, 会出现脏读, 不可重复读, 幻读
. 读已提交: 一个事务只能读取另一个事务已提交的数据, 会出现不可重复读, 幻读
. 可重复读: 通过MVCC实现数据快照, 从而实现可重复读, 会出现幻读
. 串行化: 通过表锁的方式, 实现串行化, 效率低下

.注意:
* 可重复读实现原理: 通过``MVCC``机制, 通过版本号的方式, 实现可重复读
* 串行化实现原理: 通过表锁的方式, 实现串行化, 效率低下.

=== 索引类型

.索引的优点: 提高查询效率, 降低查询时间
. 普通索引: 普通索引是最基本的索引, 没有任何限制, 可以加速查询
. 唯一索引: 唯一索引是指索引的值必须是唯一的, 不能重复, 可以加速查询
. 主键索引: 主键索引是指索引的值必须是唯一的, 不能重复, 并且不能为空, 可以加速查询
. 全文索引: 全文索引是指索引的值是全文, 可以加速查询

.聚簇索引和非聚簇索引
. 聚簇索引: 默认会使用主键作为聚簇索引, 索引键值的逻辑顺序决定了表中相应行的物理存储顺序。, 可以加速查询
. 非聚簇索引: 叶子节点存储的是索引键值和对应的主键值


=== 存储引擎

.存储引擎的区别
|===
| 序号 | 区别点 | InnoDB | MyISAM

| 1
| 事务
| 支持
| 不支持

| 2
| 锁问题
| 通过索引, 可以实现行级锁; 如果索引失效, 会锁住整个表
| 只有表级锁, 会锁住整个表

| 3
| 外键
| 支持
| 不支持

| 4
| 崩溃恢复
| 支持
| 不支持

| 5
| 文件格式
| ``.ibd``: 存储数据和索引; ``.frm``: 存储表结构
| ``.MYD``: 存储数据; ``.MYI``: 存储索引; ``.frm``: 存储表结构

|===

==== 如何解决数据的读一致性问题

.`MVCC`, 多版本并发控制, 通过版本号的方式, 实现可重复读, 通过快照的方式, 实现读一致性 (https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html[参考链接])
另一种解决方案，如果要让一个事务前后两次读取的数据保持一致，那么我们可以在修改数据的时候给它建立一个备份或者叫快照，后面再来读取这个快照就行了。这种方案我们叫做多版本的并发控制 Multi Version Concurrency Control（MVCC）

MVCC 的核心思想是： 我可以查到在我这个事务开始之前已经存在的数据，即使它在后面被修改或者删除了。在我这个事务之后新增的数据，我是查不到的。

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1650529519068/f1ac9b56aafe4ec2980b75d9235613c8.png[image.png]

通过以上演示我们能看到，通过版本号的控制，无论其他事务是插入、修改、删除，第一个事务查询到的数据都没有变化。

在 InnoDB 中，MVCC 是通过 Undo log 实现的。

Oracle、Postgres 等等其他数据库都有 MVCC 的实现。

需要注意，在 InnoDB 中，MVCC 和锁是协同使用的来实现隔离性的，这两种方案并不是互斥的。

第一大类解决方案是锁，锁又是怎么实现读一致性的呢？

==== 索引问题

.常见的索引
. `B Tree`: 平衡二叉树, 通过二分查找的方式, 查找数据.
非叶子节点可能存储数据, 也可能存储指向下一个节点的指针, 导致一个节点存储的数据有限, 增加了树的高度, 降低了查询效率
. `B+ Tree`: 平衡二叉树, 通过二分查找的方式, 查找数据, 并且叶子节点是有序的, 可以通过叶子节点进行范围查找.
非叶子节点只存储指向下一个节点的指针, 存储的数据更多, 降低了树的高度, 提高了查询效率.
正常的百万数据, 只需要三层树, 就可以查找到数据.
. `Hash索引`: 通过哈希算法, 查找数据, 但是无法进行范围查找

.索引的优缺点
. 优点: 提高查询效率, 降低查询时间
. 缺点: 增加了插入, 删除, 更新的时间, 并且占用了更多的磁盘空间

.索引失效问题
. 可能原因
* 索引字段不是最左前缀
* 索引字段使用了函数
* 索引字段使用了``or``条件
* 使用了聚合函数和联合查询

.给你一张表, 你如何设计索引？
====
. 首先要明白, 创建索引, 本质上就是创建一个新文件, 记录``索引值``与``主键值/数据地址``的对应关系.
所以创建索引的本质就是牺牲一定的编辑数据(增删改)的性能, 来提高查询数据的性能
. 其次确定表的**数据量**、**查询频率**、**查询条件**、**排序条件**等可能因素
* 情况1: 数据量小, 普通情况下满足性能要求, 可以考虑不创建索引.
如果追求极致性能, 可以通过查看执行计划和查看SQL执行过程的详细日志（主要是为了确定查询的IO次数问题）, 确定创建索引是否能提高查询性能并且与增删改带来的性能损耗相比是否值得
* 情况2: 数据量大, 普通情况下无法满足性能要求, 根据查询频率, 查询条件, 排序条件等因素, 创建索引.
一般情况下, 通过查看执行计划和查看SQL执行过程的详细日志（主要是为了确定查询的IO次数问题）
====

==== 日志文件

.日志文件
. `Bin Log`: 二进制日志, 记录了所有的数据变更, 通过``row``模式, ``statement``模式, ``mixed``模式, 记录了所有的数据变更, 用于主从复制, 数据恢复等
. `Redo Log`: 重做日志, 记录了所有的数据变更, 用于数据恢复, 通过``InnoDB``存储引擎, 通过``WAL``机制, 保证了事务的原子性, 一致性, 隔离性, 持久性
. `Undo Log`: 回滚日志, 记录了所有的数据变更, 用于事务的回滚, 通过``MVCC``机制, 保证了事务的可重复读
. `Slow Log`: 慢查询日志, 记录了所有的慢查询, 用于优化查询. 需要开启``slow_query_log``参数, 并设置``long_query_time``参数
. `Error Log`: 错误日志, 记录了所有的错误, 用于排查错误. 查询方式: ``show variables like 'log_error'``

==== 事务提交流程(SQL执行流程)

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1644586172000/01e9d3d2bfbd4910b208df11be7920ff.png[image.png]

.事务提交流程
. ``SQL``从客户端发送到服务端
. 服务端解析``SQL``, 并生成``执行计划``, 由存储引擎执行, 并修改数据
. 将修改的结果更新到``Buffer pool``中
. 记录到``Redo Log``中, 并标记为``prepare``状态
. 存储引擎返回执行结果给``server``层
. ``server``层将执行语句保存到``Bin Log``中
. ``server``层正式提交事务
. 存储引擎将``Redo Log``中的``prepare``状态修改为``commit``状态

==== Buffer pool

首先, Buffer pool是一个内存缓存, 用来存储数据页, 用来提高查询效率, 降低查询时间, 降低磁盘IO, 降低磁盘的读写次数.
可以理解为Linux的Page Cache, 用来缓存数据页.

.http://www.360doc.com/content/22/1208/11/81250822_1059437754.shtml[Buffer Pool深度解密]
. 空闲的缓存页: free双向链表, 用来表示空闲的缓存页
. 如何找到已经使用的缓存页: 已经使用的缓存页信息保存在hash表, key: 表空间+数据页号; value: 缓存页的地址
. flush链表: 被修改的数据没写入磁盘中, 这个缓存页就是脏页, 脏页会被放入flush链表中, 由后台线程负责将脏页写入磁盘中
. 淘汰策略: LRU链表, 用来表示缓存页的使用频率, 从头到尾表示最近到最久未使用的缓存页
. LRU缺点: 预读机制.
比如需要A页数据, 会将A页及其后续的几页数据一起读入内存, 这样会导致后续的几页数据也会被放入LRU链表中, 但是这几页数据可能不会被使用, 但是会占用LRU链表的空间, 从而导致LRU链表中的热数据被淘汰
. 全表扫描带来的风险: 全表扫描会将整张表的数据都读入内存, 但是这些数据可能不会被使用, 但是会占用LRU链表的空间, 从而导致LRU链表中的热数据被淘汰
. 脏页刷盘时机:

.内存淘汰策略
image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1463/1646818269011/b7557e5017a64d3c9d5431675e19aab1.png[image.png]

.LRU链表会被拆分成为两部分:
* 一部分为热数据: 5/8
* 一部分为冷数据: 3/8

.数据页第一次加载进来，放在LRU链表的什么地方？
放在冷数据区域的头部

.冷数据区域的缓存页什么时候放入热数据区域？
MySQL设定了一个规则，在 innodb_old_blocks_time 参数中，默认值为1000，也就是1000毫秒。意味着，只有把数据页加载进缓存里，在经过1s之后再次对此缓存页进行访问才会将缓存页放到LRU链表热数据区域的头部。

'''

.为什么是1秒？
****
因为通过预读机制和全表扫描加载进来的数据页通常是1秒内就加载了很多，然后对他们访问一下，这些都是1秒内完成，他们会存放在冷数据区域等待刷盘清空，基本上不太会有机会放入到热数据区域，除非在1秒后还有人访问，说明后续可能还会有人访问，才会放入热数据区域的头部。
****

==== Mysql调优案例

'''

=== `postgreSQL`

==== 数据库访问变慢

.调优策略
. ``Buffer pool``参数, 并查看缓存命中率
. 创建``索引``, 并查询索引是否生效, 以及查询效率是否整体变高, 并且注意增删改数据时索引的维护;
. 是否存在页分裂情况, 以及页分裂的原因, 以及如何解决;
. 是否存在锁等待, 以及锁等待的原因, 以及如何解决;

.调度速度变慢, 从最初的的1s每次调度,经过一年的运行变成了7m每次调度
====
. 发生的现象: 先是发现服务器的mysql进程CPU占用率很高, 一直在80%以上, 甚至最高能达到超过100%超负荷工作; 并且发现调度服务的日志打印从原来的1s一次调度, 变成了7m一次调度, 严重影响了业务的正常运行;
. 通过查询慢查询日志, 正式调度查询未完成的任务时的``SQL``, 查询条件没有创建索引, 数据库每7s, 要对百万数据进行全表扫描; 因此, 对改表的查询字段创建索引, 通过观察mysql的CPU的使用情况, 已经调度服务的日志情况，发现了明显的好转. 但是调度服务的日志仍然有4s一次调度, 远不及最初的速度
. 开始进行二次优化,
====

==== 数据库死锁问题

.数据库死锁问题
. 如何判断出死锁, 从程序上判断, 从数据库上判断
. 分析出现的原因
. 如何解决问题

==== Mysql中的int定义长度的意义

== Redis

.常见面试题
. Redis的数据结构
. 管道
. 发布订阅
. 事务
. 持久化

=== Redis的数据结构

.Redis的数据结构
====

. 首先是Redis的基本数据结构有: String, Hash, List, Set, ZSet. 其中的每个数据结构都有自己的特点.
. String: 字符串
* 虽然是字符, 但是value可以是多样的. 例如: 字符串, 数字, json字符串, 二进制数据.
* 还有一些特殊的操作, 例如: 自增, 自减, 追加, 截取, 位操作, 设置过期时间, 如果没有就创建的操作等
. Hash: 哈希.
可以简单理解为Java中的两个Map嵌套
. List: 列表.
实现更像队列的特性.
有左右区分, 可以获取特定的长度.
. Set: 集合.
无序, 不可重复.
有交集, 并集, 差集等操作.
可以随机随机获取.
. ZSet: 有序集合.
有序集合.
可以通过分数获取, 也可以通过索引获取.
====



=== 管道

.管道
可以理解成一个命令集, 一次性发给服务端, 并且由于服务端是单线程的, 所以可以保证原子性.

=== 发布订阅

.发布订阅
. 发布订阅模式, 有两个角色: 发布者, 订阅者
. 发布者发布消息, 订阅者订阅消息, 并且可以通过通配符, 进行模糊匹配
. 但是这个消息是实时的, 如果错过了就是错过了, 不会重新发送

=== 事务

.事务
. 通过``MULTI``开启事务, 通过``EXEC``提交事务, 通过``DISCARD``回滚事务
. 但是如果出现语法错误, 那么就会回滚事务, 但是如果出现业务错误, 那么就不会回滚事务
. 回滚机制: 只能对基本的语法错误进行判断回滚

=== redis锁实现

. 通过``WATCH``可以实现乐观锁, 通过``UNWATCH``可以取消乐观锁
. 通过``SETNX``可以实现悲观锁, 通过``DEL``可以取消悲观锁

=== 持久化

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1692340041074/c37331984be64075a3f78ff236a98fdf.jpg[image.png]

.AOF策略
. AOF记录每条命令, 然后写进磁盘中.
. 写进磁盘的策略:
* 每秒同步一次
* 每次写入都同步一次
* 由操作系统控制同步
. AOF重写机制. 可以理解为删除冗余的命令, 例如: 一个key, 设置了100次, 但是只需要最后一次的命令即可.
这个可以手动触发, 也可以自动触发.

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1692340041074/c37331984be64075a3f78ff236a98fdf.jpg[AOF重写过程]

.AOF重写过程
. 主线程fork出一个子进程, 把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了Redis的最新数据。

.RDB策略
. 基本原理: 指定的时间间隔内将内存中的数据集快照写入磁盘
. 实现原理: 通过fork出一个子进程, 然后将内存中的数据拷贝一份给子进程, 然后子进程将数据写入磁盘中

=== Redis过期策略

.配置项: `Maxmemory-policy`
. `noeviction`: 不删除, 可以读, 不能写, 确保消息不丢失
. `allkeys-lru`: 删除最近最少使用的key
. `volatile-lru`: 删除最近最少使用的key, 但是只删除设置了过期时间的key
. `volatile-ttl`: 尝试淘汰设置了过期时间的key, 并且优先淘汰剩余时间最短的key
. `volatile-random`: 随机删除设置了过期时间的key
. `allkeys-random`: 随机删除所有的key

=== Redis调优案例

. 缓存击穿
. 缓存穿透
. 缓存雪崩

.缓存穿透
. 问题分析: 查询的数据在数据库中不存在, 但是缓存中也不存在, 但是每次都会查询数据库, 造成数据库压力过大
. 解决方案: 设置空数据 ;过布隆过滤器, 将不存在的数据, 存放到布隆过滤器中, 这样就可以避免每次都去查询数据库

.缓存雪崩
. 问题分析: 缓存中的数据, 在同一时间, 大量的失效, 造成数据库压力过大
. 解决方案: 设置过期时间随机值, 避免同一时间大量的数据失效; 通过加锁的方式, 避免同一时间大量的数据失效

== Spring

. IOC实现原理
. 三级缓存
. Bean的生命周期
. 如何解决循环依赖
. AOP实现原理
. TX实现原理

=== IOC

.IOC实现原理
. 首先如果是通过xml配置的方式, 那么首先会解析xml文件, 并构建出``BeanDefinition``对象.
. 然后执行``BeanFactoryPostProcessor``的方法, 进行注册``BeanDefinition``对象.
例如: ``ConfigurationClassPostProcessor``就是通过这种方式, 将``@Configuration``注解的类, 注册到``BeanDefinition``中; 并修改``BeanDefinition``的属性, 例如判断该类是否需要动态代理.
. 然后就是注册些必要的接口, 例如: ``BeanPostProcessor``.
. 后面就会创建非懒加载且单例的bean对象.
创建对象可能会有多种创建方式, 例如: 通过反射的方式, 或者是通过实现特定的接口就行创建对象.
创建好的对象会先放到二级缓存中, 主要是为了提前暴露对象, 解决循环依赖和AOP的问题.
. 对象创建完之后, 就是赋值属性, 然后调用初始化方法, 最后判断是否需要AOP动态代理.
. 等处理完之后, 就会放到一级缓存中``singletonObjects``中, 并从二级缓存中移除, 然后返回对象.

=== 三级缓存

.三级缓存
. 一级缓存: ``singletonObjects`` 用于存放单例对象
. 二级缓存: ``earlySingletonObjects``: 用于存放提前暴露的对象, 主要是为了解决循环依赖和AOP的问题
. 三级缓存: ``singletonFactories`` 这个缓存用于存储用于创建Bean实例的ObjectFactory。

=== Bean的生命周期

.Bean的生命周期
. 首先通过``BeanDefinition``对象, 创建``Bean``对象
. 然后通过``BeanPostProcessor``的``postProcessBeforeInitialization``方法, 对Bean对象进行处理
. 然后调用``Bean``对象的初始化方法, 例如: ``@PostConstruct``注解的方法, ``InitializingBean``接口的方法, 自定义的初始化方法
. 然后通过``BeanPostProcessor``的``postProcessAfterInitialization``方法, 对Bean对象进行处理
. 然后调用``Bean``对象的销毁方法, 例如: ``@PreDestroy``注解的方法, ``DisposableBean``接口的方法, 自定义的销毁方法

=== 如何解决循环依赖

.解决循环依赖: 通过二级缓存, 提前暴露对象, 解决循环依赖问题 （A，B对象循环依赖）
具体解决方案:

=== AOP实现原理

.AOP实现原理
. 在Bean对象创建完之后, 然后根据后置处理器, 判断是否需要AOP动态代理, 如果需要, 则创建代理对象
. 创建代理对象的过程:
* 首先匹配当前对象的``Advisor``和``Advice``对象, 并将``Advice``对象, 转换成``MethodInterceptor``对象.
* 创建``ProxyFactory``代理工厂对象, 并判断使用CGlib还是jdk动态代理, 进行代理对象的创建.

=== TX请求处理流程

.TX请求处理流程
. 首先通过AOP拦截器, 拦截对象方法的调用.
. 判断该方法是否需要代理.
如果需要代理, 就开始执行事务的处理.
. 解析事务的属性（例如传播特性, 回滚策略等属性）.
. 然后获取事务管理器和数据库连接, 并创建事务的描述信息(TransactionInfo), 并开启事务
. 然后将事务状态通道的ThreadLocal中, 主要是用来解决事务嵌套问题
. 然后执行目标方法, 并将目标方法的执行结果返回
. 如果不出异常的话, 则正常提交事务.
如果抛异常了, 并且是指定的异常, 则回滚事务.
如果抛异常了, 并且不是指定的异常, 则不回滚事务.

== Spring mvc

. 基本架构
. 九大组件
. 请求处理流程
. 静态资源管理和请求流程
. mvc对session和cookie的管理
. 线程池的重要参数
. 参数解析（不重要）

=== 九大组件

``DispatcherServlet``: 前端控制器, 用于接收请求, 并分发给其他组件处理

.九大组件
. ``ThemeResolver``: 主题处理器，设置需要应用的整体格式
. ``HandlerMapping``: 处理器映射器, 返回请求对应的处理器和拦截器
. ``HandlerAdapter``: 处理器适配器, 用于调用处理器, 解析参数
. ``HandlerExceptionResolver``: 异常处理器, 用于处理异常
. ``ViewResolver``: 视图解析器，根据视图名称和语言，获取View视图
. ``LocaleResolver``: 区域解析器, 用于解析区域信息
. ``MultipartResolver``: 文件上传解析器, 用于解析文件上传
. ``HandlerInterceptor``: 拦截器, 用于拦截请求
. ``FlashMapManager``: FlashMap管理器，负责重定向保存参数到临时存储（默认session）中

=== 请求处理流程

.请求处理流程
. 首先请求到达``DispatcherServlet``
. 根据具体的请求找到对应的``HandlerMapping``，并获取``HandlerAdapter``适配器，``HandlerInterceptor``拦截器等组件
. 然后调用拦截器的前置拦截方法.
确定没问题之后, 调用``HandlerAdapter``的``handle``方法
. 然后解析参数
. 判断是否出现异常, 如果出现异常, 则调用异常处理器``HandlerExceptionResolver``, 进行异常处理

=== 基本架构

=== 线程池的重要参数

== Mybatis

. Mybatis的基本架构
. Mybatis的执行流程
. Mybatis plus功能 的基本原理和理解
. 你对Mybatis-plus了解多少?
有什么优缺点?
参数解析和结果解析流程?
. Spring boot如果实现Mybatis的自动装配?
. Spring boot如何配置多数据源?

=== Mybatis的基本架构

=== 执行流程

.执行流程
. 首先通过``SqlSessionFactoryBuilder``构建``SqlSessionFactory``对象
. 然后通过``SqlSessionFactory``创建``SqlSession``对象
. 然后通过``SqlSession``对象获取``Mapper``对象
. 然后通过``Mapper``对象执行``sql``语句.

== Spring boot

. Spring boot的基本原理
. 事件监听机制
. 自动装配原理
. 内嵌tomcat原理

=== 自动装配原理

.自动装配原理
. 首先通过``@EnableAutoConfiguration``注解, 开启自动装配
. 然后通过``@Import``注解, 导入``AutoConfigurationImportSelector``类, 并实现了``ImportSelector``接口. 该接口是``spring ioc``实现的接口, 用于导入所需要的Bean对象, 也就是自动装配类.
. 然后通过``AutoConfigurationImportSelector``类, 获取``META-INF/spring.factories``文件中的``EnableAutoConfiguration``的值, 并将Bean对象注册到IOC容器中.
. 然后通过条件注解``@Conditional``, 判断是否需要注册该Bean对象.
. 这样就完成了自动装配

=== 内嵌tomcat原理

.内嵌tomcat原理
. 内嵌tomcat是在 初始化完成``Spring IOC`` 容器之后
. 重写了``refresh``方法, 并创建``Tomcat``对象, 并将``Tomcat``对象注册到IOC容器中
. 并将``DispatcherServlet``注册为其中的``servlet``.


== RocketMQ


.ElasticSearch 方面：
. 掌握 ES 的基本架构，包括节点类型（主节点、数据节点等）、索引、文档等概念。
. 理解 ES 的倒排索引原理，以及如何提高搜索效率。
. 学习 ES 的数据存储和分片机制，了解如何进行数据分布和扩容。
. 熟悉 ES 的查询语法和各种查询类型（全文搜索、精确匹配等）。
. 掌握 ES 的聚合操作，能够进行数据的统计和分析。
. 了解 ES 的性能优化技巧，如索引优化、缓存设置、硬件配置等。


== Kafka

. 理解 Kafka 的架构，包括 Broker、Producer、Consumer、Topic、Partition 等核心概念。
. 掌握 Kafka 的存储机制，如消息的存储方式、索引结构等。
. 学习 Kafka 的消息传递模式，包括点对点模式和发布 / 订阅模式。
. 深入了解 Kafka 的生产者和消费者的工作原理，以及如何优化它们的性能。
. 熟悉 Kafka 的副本机制和容错处理，明白如何保证数据的可靠性和高可用性。
. 了解 Kafka 的流处理框架，如 Kafka Streams 的基本用法。
. Kafka生产者确认机制. ack=0(不确认), ack=1(主副本), ack=-1(所有副本确认)

. Kafka组织架构
. Kafka高性能原因
. ACK机制
. push 模型
. 消费模型
. kafkaProducer发送消息时，怎么确定它发送到哪个Broker
. MQ怎么解决重复消费问题?

=== Kafka组织架构

image:https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1670654953054/35d3bd71bad045dd92d5a117c71e1368.png[image.png]


=== Kafka高性能原因

顺序写、零拷贝、批量发送、分区、对log

=== ACK机制

.ACK机制
. ACK机制是指生产者发送消息后, 会收到一个ACK确认消息, 代表消息发送成功
. ACK机制有三种: 0, 1, -1
* 0: 生产者发送消息后, 不会收到ACK确认消息, 代表消息发送成功
* 1: 生产者发送消息后, 会收到ACK确认消息, 代表消息发送成功
* -1: 生产者发送消息后, 会收到ACK确认消息, 代表消息发送成功, 并且会等待ISR中的所有副本都收到消息, 才会收到ACK确认消息

=== 消费模型

.消费模型
=== 发送原理

=== kafkaProducer发送消息时，怎么确定它发送到哪个Broker

== Zookeeper

.Zookeeper 方面：
. 深入理解 Zookeeper 的基本概念，如数据模型（znode）、节点类型（持久节点、临时节点等）、Watcher 机制。
. 掌握 Zookeeper 的一致性协议，如 Zab 协议的工作原理。
. 了解 Zookeeper 的应用场景，如分布式锁、配置管理、集群管理等，并能够通过实际案例进行阐述。
. 熟悉 Zookeeper 的常用命令，能够进行一些基本的操作和问题排查。
. 研究 Zookeeper 的选举机制，包括如何选举 leader 和 follower 以及处理故障切换的过程。

.Zookeeper
. ZAB协议: 广播通知, 恢复机制
. Watch机制: 回调机制, 修改后通知节点node
. 节点特定:
.. 临时节点: 临时节点, 会话结束后删除
.. 持久节点: 持久节点, 永久存在
.. 临时顺序节点: 临时节点, 会话结束后删除, 有序
.. 持久顺序节点: 持久节点, 永久存在, 有序

=== 深入理解 Zookeeper 的基本概念

.数据模型（znode）：
- Zookeeper 的数据模型类似于文件系统，由节点（znode）组成的树状结构。每个 znode 可以存储数据（字节数组），同时还可以有子节点。

.节点类型
. 持久节点（Persistent）：创建后会一直存在于 Zookeeper 数据树中，直到被显式删除。
. 持久顺序节点（PersistentSequential）：具有持久性，并且节点名会自动加上一个递增的数字后缀，保证节点创建的顺序。
. 临时节点（Ephemeral）：与创建它的会话相关联。会话结束时，临时节点会被自动删除。
. 临时顺序节点（EphemeralSequential）：兼具临时节点和顺序节点的特点，会话结束时自动删除，且节点名有递增数字后缀。

.Watcher 机制：
Watcher 是一种一次性的事件通知机制。客户端可以在 Zookeeper 节点上设置 Watcher，当节点的数据发生变化（如创建、删除、数据修改等）时，Zookeeper 服务端会主动向设置了 Watcher 的客户端发送通知，触发客户端相应的处理逻辑。Watcher 机制使得客户端能够实时感知到 Zookeeper 中数据的变化，从而实现分布式系统中的协调和同步。

=== ZAK协议

Zookeeper 保证分布式数据一致性的核心协议

ZAB 协议的运行过程主要分为以下两个阶段：

.消息广播阶段：
. 客户端向 Zookeeper 服务器发起写请求。
. 服务器会将这个请求转化为一个事务 Proposal（提议），并为这个 proposal 分配一个全局唯一的事务 ID，即 ZXID。
. 领导者（Leader）接收到 proposal 后，会将其广播给所有的跟随者（Follower）。
. Follower 接收到 proposal 后，会将其写入本地日志，但并不提交。
. 当 Leader 收到过半数 Follower 的响应（ACK）后，会提交本地事务，并向 Follower 发送提交指令。
. Follower 收到提交指令后，提交事务。

.崩溃恢复阶段：
. 当 Leader 出现故障时，Zookeeper 进入崩溃恢复模式。
. 所有的 Follower 会停止处理新的请求。
. Follower 会选举出一个新的 Leader。
. 新 Leader 必须保证已经被提交的事务 Proposal 最终会被所有的 Follower 提交。
. 新 Leader 会与 Follower 进行数据同步，确保数据的一致性。

.ZAB 协议的实现主要依赖以下几个关键技术和机制：
. 事务 ID（ZXID）：用于标识事务的先后顺序和唯一性。
. 基于 Paxos 算法的改进：保证了分布式环境下的一致性决策。
. 数据同步和恢复机制：确保在故障情况下数据的完整性和一致性。

总之，ZAB 协议通过消息广播和崩溃恢复机制，保证了 Zookeeper 集群在分布式环境下的数据一致性和可靠性。

=== Zookeeper 的应用场景

.Zookeeper 的应用场景
. 分布式锁：`临时顺序节点` + `watch机制`.
. 配置管理：Zookeeper 可以用于管理分布式系统的配置信息，实现配置的动态更新和共享。
. 服务注册与发现：Zookeeper 可以用于实现分布式系统中的服务注册与发现机制，使得服务提供者和消费者能够动态地进行注册和发现。
. 分布式协调：Zookeeper 可以用于实现分布式系统中的协调机制，例如分布式锁、分布式计数器等。

=== 基本的操作和问题排查

.常见的问题:
. Zookeeper


=== Watch机制: 回调机制, 修改后通知节点node

.Watch机制
. Watch机制是一种回调机制, 当节点发生变化时, 会通知客户端

=== 节点特定

.节点特定
. 持久节点: 持久节点, 永久存在
. 临时节点: 临时节点, 会话结束后删除
. 临时顺序节点: 临时节点, 会话结束后删除, 有序
. 持久顺序节点: 持久节点, 永久存在, 有序

== ElasticSearch

.常见面试题
. 基本概念
. 基本数据类型
. 详细描述 `ES` 存储过程
. 详细描述一下Elasticsearch搜索的过程？
. Beats 如何与 Elasticsearch 结合使用
. 解释一下 Elasticsearch 的 分片？
. 精准匹配检索和全文检索匹配检索的不同？
. 您能否说明当前可下载的稳定Elasticsearch版本？

=== 基本概念

.核心概念
. `索引`: 索引是一个包含了一组文档的逻辑容器。类似于关系型数据库中的数据库表。
. `文档`: 文档是 Elasticsearch 中的基本数据单元，类似于关系型数据库中的行。
. `字段`: 字段是文档中的一个属性，用于存储数据。
. `类型`: 类型是索引中的一个逻辑分类，用于存储具有相同结构的文档。
. `映射`: 映射是定义索引中字段的结构和属性的配置。
. `分片`: 分片是将索引分成多个部分的过程，每个分片可以存储在不同的节点上。
. `副本`: 副本是分片的副本，用于提供高可用性和容错性。
. `节点`: 节点是 Elasticsearch 集群中的一个服务器实例，可以存储数据和执行搜索操作。

=== 基本数据类型

.基本数据类型
. 字符串类型: string
. 数值类型: byte, short, integer, long, float, double
. 布尔类型: boolean
. 日期类型: date
. 二进制类型: binary
. 范围类型: range
. 地理类型: geo_point, geo_shape
. 嵌套类型: nested
. 特殊类型: ip, completion, token_count, percol

=== 详细描述 `ES` 存储过程

.详细描述 `ES` 存储过程
. 首先客户端发送数据插入请求
. 然后ES接收到请求, 并解析请求
. 根据数据, 计算出Hash, 并将数据存储到对应的分片中
. 然后ES将数据存储到磁盘中
. 最后ES返回响应给客户端

=== 详细描述一下Elasticsearch搜索的过程？

sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://p0m4l8ep.mirror.aliyuncs.com"]
}
EOF


.详细描述一下Elasticsearch搜索的过程？
. 客户端向某一节点发送搜索请求
.

== Dubbo

== 微服务

== 分布式事务

. 常见的分布式事务解决方案？
. 什么是Seata？
. Seata分布式事务框架实现原理？
. LCN分布式事务框架实现原理？
. 分布式锁的实现(Redis, Zookeeper)
. 分布式锁的实现(Zookeeper)

=== 常见的分布式事务解决方案？

. LCN
. Seata
. 2PC、3PC
. 分布式锁的实现(Redis, Zookeeper)

.Seata
. AT: 两阶段提交; 通过TM开启全局事务, 然后通过RM开启本地事务, 执行并提交本地事务, 然后通过TM提交全局事务; 第二阶段, TC通知RM提交本地事务, 然后通过TM提交全局事务, 如果有异常, 则通过TM回滚全局事务
. XA: 两阶段提交:
. TCC: 两阶段提交; Try, Confirm or Cancel.
通过Try阶段, 预留资源, 然后通过Confirm阶段, 确认资源, 最后通过Cancel阶段, 取消资源.
这种模式的特点不需要数据库支事物
. SAGA:

=== 什么是Seata？

Seata是阿里巴巴退出的一款用来解决分布式事务问题的框架，他经过天猫双十一的考验，很有可能成为解决分布式事务问题的主流框架

.Seata有三个组成部分：
. 事务协调器TC：协调者.
主要用于协调全局事务的提交和回滚
. 事务管理器TM：发起方, 同时也可以是RM.
主要用于开启全局事务
. 资源管理器RM: 参与方.
主要用于操作本地事务

==== AT模式

.TM执行全局事务流程:
. 第一阶段:
.. 向``TC``申请全局事务, 并返回全局事务ID(XID).(由TC生成并返回)
.. 然后向``RM``请求本地事务(``XID``会由拦截器转发并写到请求头中)
.. ``RM``执行完毕后, 通知``TC``本地事务执行结果, 并返回给``TM``业务执行结果
. 第二阶段:
.. ``TM``收到所有``RM``的执行结果后, 向``TC``请求``提交或者回滚全局事务``
.. ``TC``收到``TM``的请求后, 通知``RM``提交或者回滚本地事务, 并删除``undo_log``表数据
.. ``TC``收到``RM``的执行结果后, 返回给``TM``业务执行结果.
表示全局事务执行完毕

.AT模式``RM``运行流程
image::https://img-blog.csdnimg.cn/6feac2bef42442a2b754d13c089769b8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSn5qCR5YWI55SfLg==,size_20,color_FFFFFF,t_70,g_se,x_16[]

.RM执行全局事务流程
. 解析SQL
. 查询前置镜像数据
. 执行业务SQL
. 查询出后置镜像数据
. 插入undo_log
. 提交本地事务之前, 向TC申请全局锁
. 提交本地事务, 并释放本地锁, 并向TC通知和释放全局锁
. `二阶段提交`, 等待TC通知, 并释放全局锁, 并删除``undo_log``表数据

== 运维知识

=== Linux

=== Docker

=== K8s

=== Shell脚本